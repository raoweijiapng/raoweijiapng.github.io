<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Kafka特性之物理存储 | WeiJia_Rao</title><meta name="keywords" content="Java Hadoop"><meta name="author" content="WeiJia Rao"><meta name="copyright" content="WeiJia Rao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="⽇志存储 概述 Kafka 消息是以主题为单位进⾏归类，各个主题之间是彼此独⽴的，互不影响。 每个主题⼜可以分为⼀个或多个分区。 每个分区各⾃存在⼀个记录消息数据的⽇志⽂件。       图中，创建了⼀个 tp_demo_01 主题，其存在6个 Parition，对应的每个Parition下存在⼀个 [Topic-Parition] 命名的消息⽇志⽂件。在理想情况下，数据流量分摊到各个 Parit">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka特性之物理存储">
<meta property="og:url" content="https://raoweijiapng.gitee.io/posts/3481392046/index.html">
<meta property="og:site_name" content="WeiJia_Rao">
<meta property="og:description" content="⽇志存储 概述 Kafka 消息是以主题为单位进⾏归类，各个主题之间是彼此独⽴的，互不影响。 每个主题⼜可以分为⼀个或多个分区。 每个分区各⾃存在⼀个记录消息数据的⽇志⽂件。       图中，创建了⼀个 tp_demo_01 主题，其存在6个 Parition，对应的每个Parition下存在⼀个 [Topic-Parition] 命名的消息⽇志⽂件。在理想情况下，数据流量分摊到各个 Parit">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raoweijiapng.gitee.io/img/6.jpg">
<meta property="article:published_time" content="2022-07-27T02:17:46.000Z">
<meta property="article:modified_time" content="2022-07-27T09:41:36.000Z">
<meta property="article:author" content="WeiJia Rao">
<meta property="article:tag" content="Java Hadoop">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raoweijiapng.gitee.io/img/6.jpg"><link rel="shortcut icon" href="/img/networkPhoto.jpg"><link rel="canonical" href="https://raoweijiapng.gitee.io/posts/3481392046/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a9e49a68498fd088e63e2fe8907ca570";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kafka特性之物理存储',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-27 17:41:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/authorPhoto.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">409</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">64</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">57</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/6.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">WeiJia_Rao</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kafka特性之物理存储</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-27T02:17:46.000Z" title="发表于 2022-07-27 10:17:46">2022-07-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-27T09:41:36.000Z" title="更新于 2022-07-27 17:41:36">2022-07-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Kafka/">Kafka</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Kafka特性之物理存储"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="⽇志存储">⽇志存储</h2>
<h3 id="概述-2">概述</h3>
<p>Kafka 消息是以主题为单位进⾏归类，各个主题之间是彼此独⽴的，互不影响。</p>
<p>每个主题⼜可以分为⼀个或多个分区。</p>
<p>每个分区各⾃存在⼀个记录消息数据的⽇志⽂件。</p>
  <img src="/posts/3481392046/1.jpg" class="post-image">
  <br>
<p>图中，创建了⼀个 tp_demo_01 主题，其存在6个 Parition，对应的每个Parition下存在⼀个 [Topic-Parition] 命名的消息⽇志⽂件。在理想情况下，数据流量分摊到各个 Parition 中，实现了负载均衡的效果。在分区⽇志⽂件中，你会发现很多类型的⽂件，⽐如： .index、.timestamp、.log、.snapshot 等。</p>
<p>其中，⽂件名⼀致的⽂件集合就称为 LogSement。</p>
  <img src="/posts/3481392046/2.jpg" class="post-image">
  <br>
<ul>
<li>
<p>LogSegment</p>
<ol>
<li>
<p>分区⽇志⽂件中包含很多的 LogSegment</p>
</li>
<li>
<p>Kafka ⽇志追加是顺序写⼊的</p>
</li>
<li>
<p>LogSegment 可以减⼩⽇志⽂件的⼤⼩</p>
</li>
<li>
<p>进⾏⽇志删除的时候和数据查找的时候可以快速定位。</p>
</li>
<li>
<p>ActiveLogSegment 是活跃的⽇志分段，拥有⽂件拥有写⼊权限，其余的 LogSegment 只有只读的权限。</p>
</li>
<li>
<p>⽇志⽂件存在多种后缀⽂件，重点需要关注 .index、.timestamp、.log 三种类型。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>后缀名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.index</td>
<td>偏移量索引⽂件</td>
</tr>
<tr>
<td>.timestamp</td>
<td>时间戳索引⽂件</td>
</tr>
<tr>
<td>.log</td>
<td>⽇志⽂件</td>
</tr>
<tr>
<td>.snapshot</td>
<td>快照⽂件</td>
</tr>
<tr>
<td>.deleted</td>
<td>预删除文件</td>
</tr>
<tr>
<td>.cleaned</td>
<td>⽇志清理时临时⽂件</td>
</tr>
<tr>
<td>.swap</td>
<td>⽇志压缩之后的临时⽂件</td>
</tr>
<tr>
<td>leader-epoch-checkpoint</td>
<td></td>
</tr>
</tbody>
</table>
<p>每个 LogSegment 都有⼀个基准偏移量，表示当前 LogSegment 中第⼀条消息的 offset。</p>
<p>偏移量是⼀个 64 位的⻓整形数，固定是20位数字，⻓度未达到，⽤ 0 进⾏填补，索引⽂件和⽇志⽂件都由该作为⽂件名命名规则（00000000000000000000.index、00000000000000000000.timestamp、00000000000000000000.log）。</p>
<p>如果⽇志⽂件名为 00000000000000000121.log ，则当前⽇志⽂件的⼀条数据偏移量就是 121（偏移量从 0 开始）。</p>
<table>
<thead>
<tr>
<th>配置条⽬</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>log.index.interval.bytes</td>
<td>4096(4K)</td>
<td>增加索引项字节间隔密度，会影响索引⽂件中的区间密度和查询效率</td>
</tr>
<tr>
<td>log.segment.bytes</td>
<td>1073741824(1G)</td>
<td>⽇志⽂件最⼤值</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://log.roll.ms">log.roll.ms</a></td>
<td></td>
<td>当前⽇志分段中消息的最⼤时间戳与当前系统的时间戳的差值允许的最⼤范围，单位毫秒</td>
</tr>
<tr>
<td>log.roll.hours</td>
<td>168(7天)</td>
<td>当前⽇志分段中消息的最⼤时间戳与当前系统的时间戳的差值允许的最⼤范围，单位⼩时</td>
</tr>
<tr>
<td>log.index.size.max.bytes</td>
<td>10485760(10MB)</td>
<td>触发偏移量索引⽂件或时间戳索引⽂件分段字节限额</td>
</tr>
</tbody>
</table>
<p>偏移量索引⽂件⽤于记录消息偏移量与物理地址之间的映射关系。</p>
<p>时间戳索引⽂件则根据时间戳查找对应的偏移量。</p>
<p>Kafka 中的索引⽂件是以稀疏索引的⽅式构造消息的索引，并不保证每⼀个消息在索引⽂件中都有对应的索引项。</p>
<p>每当写⼊⼀定量的消息时，偏移量索引⽂件和时间戳索引⽂件分别增加⼀个偏移量索引项和时间戳索引项。</p>
<p>通过修改 log.index.interval.bytes 的值，改变索引项的密度。</p>
</li>
<li>
<p>切分⽂件</p>
<p>当满⾜如下⼏个条件中的其中之⼀，就会触发⽂件的切分：</p>
<ol>
<li>
<p>当前⽇志分段⽂件的⼤⼩超过了 broker 端参数 log.segment.bytes 配置的值。 log.segment.bytes 参数的默认值为 1073741824，即 1GB。</p>
</li>
<li>
<p>当前⽇志分段中消息的最⼤时间戳与当前系统的时间戳的差值⼤于 <a target="_blank" rel="noopener" href="http://log.roll.ms">log.roll.ms</a> 或 log.roll.hours 参数配置的值。如果同时配置了 <a target="_blank" rel="noopener" href="http://log.roll.ms">log.roll.ms</a> 和 log.roll.hours 参数，那么 <a target="_blank" rel="noopener" href="http://log.roll.ms">log.roll.ms</a> 的优先级⾼。默认情况下，只配置了 log.roll.hours 参数，其值为168，即 7 天。</p>
</li>
<li>
<p>偏移量索引⽂件或时间戳索引⽂件的⼤⼩达到 broker 端参数 log.index.size.max.bytes 配置的值。 log.index.size.max.bytes 的默认值为 10485760，即 10MB。</p>
</li>
<li>
<p>追加的消息的偏移量与当前⽇志分段的偏移量之间的差值⼤于 Integer.MAX_VALUE ，即要追加的消息的偏移量不能转变为相对偏移量。</p>
</li>
</ol>
<ul>
<li>
<p>为什么是 Integer.MAX_VALUE ？</p>
<p>大小 1024 * 1024 * 1024=1073741824</p>
<p>在偏移量索引⽂件中，每个索引项共占⽤ 8 个字节，并分为两部分。相对偏移量和物理地址。</p>
<p>相对偏移量：表示消息相对与基准偏移量的偏移量，占 4 个字节</p>
<p>物理地址：消息在⽇志分段⽂件中对应的物理位置，也占 4 个字节</p>
<p>4 个字节刚好对应 Integer.MAX_VALUE ，如果⼤于 Integer.MAX_VALUE ，则不能⽤ 4 个字节进⾏表示了。</p>
</li>
</ul>
</li>
<li>
<p>索引⽂件切分过程</p>
<p>索引⽂件会根据 log.index.size.max.bytes 值进⾏预先分配空间，即⽂件创建的时候就是最⼤值。</p>
<p>当真正的进⾏索引⽂件切分的时候，才会将其裁剪到实际数据⼤⼩的⽂件。</p>
<p>这⼀点是跟⽇志⽂件有所区别的地⽅。其意义降低了代码逻辑的复杂性。</p>
</li>
</ul>
<h3 id="存储">存储</h3>
<h4 id="索引-2">索引</h4>
<p>偏移量索引⽂件⽤于记录消息偏移量与物理地址之间的映射关系。时间戳索引⽂件则根据时间戳查找对应的偏移量。</p>
<p>查看⼀个topic分区⽬录下的内容，发现有log、index和timeindex三个⽂件：</p>
<ol>
<li>
<p>log⽂件名是以⽂件中第⼀条message的offset来命名的，实际offset⻓度是64位，但是这⾥只使⽤了20位，应付⽣产是⾜够的。</p>
</li>
<li>
<p>⼀组index+log+timeindex⽂件的名字是⼀样的，并且log⽂件默认写满1G后，会进⾏log rolling形成⼀个新的组合来记录消息，这个是通过broker端 log.segment.bytes =1073741824指定的。</p>
</li>
<li>
<p>index和timeindex在刚使⽤时会分配10M的⼤⼩，当进⾏ log rolling 后，它会修剪为实际的⼤⼩。</p>
</li>
</ol>
  <img src="/posts/3481392046/3.jpg" class="post-image">
  <br>
<ul>
<li>
<p>1、创建主题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# kafka-topics.sh --zookeeper node1:2181/myKafka --create --topic tp_demo_05 --partitions 1 --replication-factor 1 --config segment.bytes=104857600</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>2、创建消息⽂件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# for i in `seq 10000000`; do echo &quot;hello lagou $i&quot; &gt;&gt; nmm.txt; done</span><br></pre></td></tr></table></figure>
<img src="/posts/3481392046/4.jpg" class="post-image">
<br>
</li>
<li>
<p>3、将⽂本消息⽣产到主题中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# kafka-console-producer.sh --broker-list node1:9092 --topic tp_demo_05 &lt; nmm.txt</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>4、查看存储⽂件</p>
<img src="/posts/3481392046/5.jpg" class="post-image">
<br>
</li>
<li>
<p>5、查看log⽂件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 tp_demo_05-0]# kafka-run-class.sh kafka.tools.DumpLogSegments --files 00000000000000000000.log --print-data-log | head</span><br><span class="line">Dumping 00000000000000000000.log</span><br><span class="line">Starting offset: 0</span><br><span class="line">baseOffset: 0 lastOffset: 716 baseSequence: -1 lastSequence: -1 producerId: -1</span><br><span class="line">producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 0</span><br><span class="line">CreateTime: 1596513421661 isvalid: true size: 16380 magic: 2 compresscodec: NONE crc:</span><br><span class="line">2973274901</span><br><span class="line">baseOffset: 717 lastOffset: 1410 baseSequence: -1 lastSequence: -1 producerId: -1</span><br><span class="line">producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 16380</span><br><span class="line">CreateTime: 1596513421715 isvalid: true size: 16371 magic: 2 compresscodec: NONE crc:</span><br><span class="line">1439993110</span><br><span class="line">baseOffset: 1411 lastOffset: 2092 baseSequence: -1 lastSequence: -1 producerId: -1</span><br><span class="line">producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 32751</span><br><span class="line">CreateTime: 1596513421747 isvalid: true size: 16365 magic: 2 compresscodec: NONE crc:</span><br><span class="line">3528903590</span><br><span class="line">baseOffset: 2093 lastOffset: 2774 baseSequence: -1 lastSequence: -1 producerId: -1</span><br><span class="line">producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 49116</span><br><span class="line">CreateTime: 1596513421791 isvalid: true size: 16365 magic: 2 compresscodec: NONE crc:</span><br><span class="line">763876977</span><br><span class="line">baseOffset: 2775 lastOffset: 3456 baseSequence: -1 lastSequence: -1 producerId: -1</span><br><span class="line">producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 65481</span><br><span class="line">CreateTime: 1596513421795 isvalid: true size: 16365 magic: 2 compresscodec: NONE crc:</span><br><span class="line">2218198476</span><br><span class="line">baseOffset: 3457 lastOffset: 4138 baseSequence: -1 lastSequence: -1 producerId: -1</span><br><span class="line">producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 81846</span><br><span class="line">CreateTime: 1596513421798 isvalid: true size: 16365 magic: 2 compresscodec: NONE crc:</span><br><span class="line">4018065070</span><br><span class="line">baseOffset: 4139 lastOffset: 4820 baseSequence: -1 lastSequence: -1 producerId: -1</span><br><span class="line">producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 98211</span><br><span class="line">CreateTime: 1596513421802 isvalid: true size: 16365 magic: 2 compresscodec: NONE crc:</span><br><span class="line">3073882858</span><br><span class="line">baseOffset: 4821 lastOffset: 5502 baseSequence: -1 lastSequence: -1 producerId: -1</span><br><span class="line">producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 114576</span><br><span class="line">CreateTime: 1596513421819 isvalid: true size: 16365 magic: 2 compresscodec: NONE crc:</span><br><span class="line">207330377</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>offset是逐渐增加的整数，每个offset对应⼀个消息的偏移量。</p>
</li>
<li>
<p>position：消息批字节数，⽤于计算物理地址。</p>
</li>
<li>
<p>CreateTime：时间戳。</p>
</li>
<li>
<p>magic：2代表这个消息类型是V2，如果是0则代表是V0类型，1代表V1类型。</p>
</li>
<li>
<p>compresscodec：None说明没有指定压缩类型，kafka⽬前提供了4种可选择，0-None、1-GZIP、2-snappy、3-lz4。</p>
</li>
<li>
<p>crc：对所有字段进⾏校验后的crc值。</p>
</li>
</ul>
</li>
<li>
<p>消息存储</p>
<ol>
<li>
<p>消息内容保存在log⽇志⽂件中。</p>
</li>
<li>
<p>消息封装为Record，追加到log⽇志⽂件末尾，采⽤的是<strong>顺序写模式</strong>。</p>
</li>
<li>
<p>⼀个topic的不同分区，可认为是queue，顺序写⼊接收到的消息。</p>
</li>
</ol>
<img src="/posts/3481392046/6.jpg" class="post-image">
<br>
<p>消费者有offset。下图中，消费者A消费的offset是9，消费者B消费的offset是11，不同的消费者offset是交给⼀个内部公共topic来记录的。</p>
<img src="/posts/3481392046/7.jpg" class="post-image">
<br>
<p>时间戳索引⽂件，它的作⽤是可以让⽤户查询某个时间段内的消息，它⼀条数据的结构是时间戳（8byte） +相对offset（4byte），如果要使⽤这个索引⽂件，⾸先需要通过时间范围，找到对应的相对offset，然后再去对应的    index⽂件找到position信息，然后才能遍历log⽂件，它也是需要使⽤上⾯说的index⽂件的。</p>
<p>但是由于producer⽣产消息可以指定消息的时间戳，这可能将导致消息的时间戳不⼀定有先后顺序，因此尽量<strong>不要⽣产消息时指定时间戳</strong>。</p>
</li>
</ul>
<h5 id="偏移量">偏移量</h5>
<ol>
<li>
<p>位置索引保存在index⽂件中</p>
</li>
<li>
<p>log⽇志默认每写⼊4K（log.index.interval.bytes设定的），会写⼊⼀条索引信息到index⽂件中，因此索引⽂件是稀疏索引，它不会为每条⽇志都建⽴索引信息。</p>
</li>
<li>
<p>log⽂件中的⽇志，是顺序写⼊的，由message+实际offset+position组成</p>
</li>
<li>
<p>索引⽂件的数据结构则是由相对offset（4byte）+position（4byte）组成，由于保存的是相对第⼀个消息的相对offset，只需要4byte就可以了，可以节省空间，在实际查找后还需要计算回实际的offset，这对⽤户是透明的。</p>
</li>
</ol>
<p>稀疏索引，索引密度不⾼，但是offset有序，⼆分查找的时间复杂度为O(lgN)，如果从头遍历时间复杂度是O(N)。</p>
<p>示意图如下：</p>
  <img src="/posts/3481392046/8.jpg" class="post-image">
  <br>
<p>偏移量索引由相对偏移量和物理地址组成。</p>
  <img src="/posts/3481392046/9.jpg" class="post-image">
  <br>
<p>可以通过如下命令解析 .index ⽂件</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-run-class.sh kafka.tools.DumpLogSegments --files 00000000000000000000.index --print-data-log | head</span><br></pre></td></tr></table></figure>
<p><strong>注意：offset 与 position 没有直接关系，因为会删除数据和清理⽇志。</strong></p>
  <img src="/posts/3481392046/10.jpg" class="post-image">
  <br>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 tp_demo_05-0]# kafka-run-class.sh kafka.tools.DumpLogSegments --files 00000000000003925423.log --print-data-log | head</span><br><span class="line">Dumping 00000000000003925423.log</span><br><span class="line">Starting offset: 3925423</span><br><span class="line">baseOffset: 3925423 lastOffset: 3926028 baseSequence: -1 lastSequence: -1 producerId:</span><br><span class="line">-1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 0</span><br><span class="line">CreateTime: 1596513434779 isvalid: true size: 16359 magic: 2 compresscodec: NONE crc:</span><br><span class="line">4049330741</span><br><span class="line">baseOffset: 3926029 lastOffset: 3926634 baseSequence: -1 lastSequence: -1 producerId:</span><br><span class="line">-1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 16359</span><br><span class="line">CreateTime: 1596513434786 isvalid: true size: 16359 magic: 2 compresscodec: NONE crc:</span><br><span class="line">2290699169</span><br><span class="line">baseOffset: 3926635 lastOffset: 3927240 baseSequence: -1 lastSequence: -1 producerId:</span><br><span class="line">-1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 32718</span><br><span class="line">CreateTime: 1596513434787 isvalid: true size: 16359 magic: 2 compresscodec: NONE crc:</span><br><span class="line">368995405</span><br><span class="line">baseOffset: 3927241 lastOffset: 3927846 baseSequence: -1 lastSequence: -1 producerId:</span><br><span class="line">-1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 49077</span><br><span class="line">CreateTime: 1596513434788 isvalid: true size: 16359 magic: 2 compresscodec: NONE crc:</span><br><span class="line">143415655</span><br><span class="line">baseOffset: 3927847 lastOffset: 3928452 baseSequence: -1 lastSequence: -1 producerId:</span><br><span class="line">-1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 65436</span><br><span class="line">CreateTime: 1596513434789 isvalid: true size: 16359 magic: 2 compresscodec: NONE crc:</span><br><span class="line">572340120</span><br><span class="line">baseOffset: 3928453 lastOffset: 3929058 baseSequence: -1 lastSequence: -1 producerId:</span><br><span class="line">-1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 81795</span><br><span class="line">CreateTime: 1596513434790 isvalid: true size: 16359 magic: 2 compresscodec: NONE crc:</span><br><span class="line">1029643347</span><br><span class="line">baseOffset: 3929059 lastOffset: 3929664 baseSequence: -1 lastSequence: -1 producerId:</span><br><span class="line">-1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 98154</span><br><span class="line">CreateTime: 1596513434791 isvalid: true size: 16359 magic: 2 compresscodec: NONE crc:</span><br><span class="line">2163818250</span><br><span class="line">baseOffset: 3929665 lastOffset: 3930270 baseSequence: -1 lastSequence: -1 producerId:</span><br><span class="line">-1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false position: 114513</span><br><span class="line">CreateTime: 1596513434792 isvalid: true size: 16359 magic: 2 compresscodec: NONE crc:</span><br><span class="line">3747213735</span><br></pre></td></tr></table></figure>
<p>在偏移量索引⽂件中，索引数据都是顺序记录 offset ，但时间戳索引⽂件中每个追加的索引时间戳必须⼤于之前追加的索引项，否则不予追加。在 Kafka 0.11.0.0 以后，消息元数据中存在若⼲的时间戳信息。如果 broker 端参数 log.message.timestamp.type 设置为 LogAppendTIme ，那么时间戳必定能保持单调增⻓。反之如果是CreateTime 则⽆法保证顺序。</p>
<p><strong>注意：timestamp⽂件中的 offset 与 index ⽂件中的 relativeOffset 不是⼀⼀对应的。因为数据的写⼊是各⾃追加。</strong></p>
<p><strong>如何查看偏移量为23的消息？</strong></p>
<p>Kafka 中存在⼀个 ConcurrentSkipListMap 来保存在每个⽇志分段，通过跳跃表⽅式，定位到在00000000000000000000.index ，通过⼆分法在偏移量索引⽂件中找到不⼤于 23 的最⼤索引项，即 offset 20 那栏，然后从⽇志分段⽂件中的物理位置为320 开始顺序查找偏移量为 23 的消息。</p>
<h5 id="时间戳">时间戳</h5>
<p>在偏移量索引⽂件中，索引数据都是顺序记录 offset ，但时间戳索引⽂件中每个追加的索引时间戳必须⼤于之前追加的索引项，否则不予追加。在 Kafka 0.11.0.0 以后，消息信息中存在若⼲的时间戳信息。如果 broker 端参数 log.message.timestamp.type 设置为 LogAppendTIme ，那么时间戳必定能保持单调增⻓。反之如果是 CreateTime 则⽆法保证顺序。</p>
<p>通过时间戳⽅式进⾏查找消息，需要通过查找<strong>时间戳索引</strong>和<strong>偏移量索引</strong>两个⽂件。</p>
<p>时间戳索引索引格式：前⼋个字节表示<strong>时间戳</strong>，后四个字节表示<strong>偏移量</strong>。</p>
  <img src="/posts/3481392046/11.jpg" class="post-image">
  <br>
  <img src="/posts/3481392046/12.jpg" class="post-image">
  <br>
<p><strong>查找时间戳为 1557554753430 开始的消息？</strong></p>
<ol>
<li>
<p>查找该时间戳应该在哪个⽇志分段中。将1557554753430和每个⽇志分段中最⼤时间戳largestTimeStamp逐⼀对⽐，直到找到不⼩于1557554753430所对应的⽇志分段。⽇志分段中的largestTimeStamp的计算是：先查询该⽇志分段所对应时间戳索引⽂件，找到最后⼀条索引项，若最后⼀条索引项的时间戳字段值⼤于0，则取该值，否则取该⽇志分段的最近修改时间。</p>
</li>
<li>
<p>查找该⽇志分段的偏移量索引⽂件，查找该偏移量对应的物理地址。</p>
</li>
<li>
<p>⽇志⽂件中从 320 的物理位置开始查找不⼩于 1557554753430 数据。</p>
</li>
</ol>
<p><strong>注意：timestamp⽂件中的 offset 与 index ⽂件中的 relativeOffset 不是⼀⼀对应的，因为数据的写⼊是各⾃追加。</strong></p>
<h4 id="清理">清理</h4>
<p>Kafka 提供两种⽇志清理策略：</p>
<p>⽇志删除：按照⼀定的删除策略，将不满⾜条件的数据进⾏数据删除。</p>
<p>⽇志压缩：针对每个消息的 Key 进⾏整合，对于有相同 Key 的不同 Value 值，只保留最后⼀个版本。</p>
<p>Kafka 提供 log.cleanup.policy 参数进⾏相应配置，默认值： delete ，还可以选择 compact 。</p>
<p>主题级别的配置项是 cleanup.policy 。</p>
<h5 id="⽇志删除">⽇志删除</h5>
<ul>
<li>
<p>基于时间</p>
<p>⽇志删除任务会根据 log.retention.hours/log.retention.minutes/log.retention.ms 设定⽇志保留的时间节点。如果超过该设定值，就需要进⾏删除。默认是 7 天， <a target="_blank" rel="noopener" href="http://log.retention.ms">log.retention.ms</a> 优先级最⾼。</p>
<p>Kafka 依据⽇志分段中最⼤的时间戳进⾏定位。</p>
<p>⾸先要查询该⽇志分段所对应的时间戳索引⽂件，查找时间戳索引⽂件中最后⼀条索引项，若最后⼀条索引项的时间戳字段值⼤于 0，则取该值，否则取最近修改时间。</p>
<p><strong>为什么不直接选最近修改时间呢？</strong></p>
<p>因为⽇志⽂件可以有意⽆意的被修改，并不能真实的反应⽇志分段的最⼤时间信息。</p>
<p><strong>删除过程</strong></p>
<ol>
<li>
<p>从⽇志对象中所维护⽇志分段的跳跃表中移除待删除的⽇志分段，保证没有线程对这些⽇志分段进⾏读取操作。</p>
</li>
<li>
<p>这些⽇志分段所有⽂件添加 上 .delete 后缀。</p>
</li>
<li>
<p>交由⼀个以 “delete-file” 命名的延迟任务来删除这些 .delete 为后缀的⽂件。<a href="http://xn--file-9f3c646p8mhh3wt8glrjr63jciaq1aj96d.delete.delay.ms">延迟执⾏时间可以通过file.delete.delay.ms</a> 进⾏设置</p>
</li>
</ol>
<p><strong>如果活跃的⽇志分段中也存在需要删除的数据时？</strong></p>
<p>Kafka 会先切分出⼀个新的⽇志分段作为活跃⽇志分段，该⽇志分段不删除，删除原来的⽇志分段。先腾出地⽅，再删除。</p>
</li>
<li>
<p>基于⽇志⼤⼩</p>
<p>⽇志删除任务会检查当前⽇志的⼤⼩是否超过设定值。设定项为 log.retention.bytes ，单个⽇志分段的⼤⼩由 log.segment.bytes 进⾏设定。</p>
<p><strong>删除过程</strong></p>
<ol>
<li>
<p>计算需要被删除的⽇志总⼤⼩ (当前⽇志⽂件⼤⼩（所有分段）减去retention值)。</p>
</li>
<li>
<p>从⽇志⽂件第⼀个 LogSegment 开始查找可删除的⽇志分段的⽂件集合。</p>
</li>
<li>
<p>执⾏删除。</p>
</li>
</ol>
</li>
<li>
<p>基于偏移量</p>
<p>根据⽇志分段的下⼀个⽇志分段的起始偏移量是否⼤于等于⽇志⽂件的起始偏移量，若是，则可以删除此⽇志分段。</p>
<p>注意：⽇志⽂件的起始偏移量并不⼀定等于第⼀个⽇志分段的基准偏移量，存在数据删除，可能与之相等的那条数据已经被删除了。</p>
<img src="/posts/3481392046/13.jpg" class="post-image">
<br>
<p><strong>删除过程</strong></p>
<ol>
<li>
<p>从头开始遍历每个⽇志分段，⽇志分段1的下⼀个⽇志分段的起始偏移量为21，⼩于logStartOffset，将⽇志分段1加⼊到删除队列中</p>
</li>
<li>
<p>⽇志分段 2 的下⼀个⽇志分段的起始偏移量为35，⼩于 logStartOffset，将 ⽇志分段 2 加⼊到删除队列中</p>
</li>
<li>
<p>⽇志分段 3 的下⼀个⽇志分段的起始偏移量为57，⼩于logStartOffset，将⽇志分段3加⼊删除集合中</p>
</li>
<li>
<p>⽇志分段4的下⼀个⽇志分段的其实偏移量为71，⼤于logStartOffset，则不进⾏删除。</p>
</li>
</ol>
</li>
</ul>
<h5 id="⽇志压缩">⽇志压缩</h5>
<ul>
<li>
<ol>
<li>概念</li>
</ol>
<p>⽇志压缩是Kafka的⼀种机制，可以提供较为细粒度的记录保留，⽽不是基于粗粒度的基于时间的保留。</p>
<p>对于具有相同的Key，⽽数据不同，只保留最后⼀条数据，前⾯的数据在合适的情况下删除。</p>
</li>
<li>
<ol start="2">
<li>应⽤场景</li>
</ol>
<p>⽇志压缩特性，就实时计算来说，可以在异常容灾⽅⾯有很好的应⽤途径。⽐如，我们在Spark、Flink中做实时计算时，需要⻓期在内存⾥⾯维护⼀些数据，这些数据可能是通过聚合了⼀天或者⼀周的⽇志得到的，这些数据⼀旦由于异常因素（内存、⽹络、磁盘等）崩溃了，从头开始计算需要很⻓的时间。⼀个⽐较有效可⾏的⽅式就是定时将内存⾥的数据备份到外部存储介质中，当崩溃出现时，再从外部存储介质中恢复并继续计算。</p>
<p>使⽤⽇志压缩来替代这些外部存储有哪些优势及好处呢？这⾥为⼤家列举并总结了⼏点：</p>
<ul>
<li>
<p>Kafka即是数据源⼜是存储⼯具，可以简化技术栈，降低维护成本</p>
</li>
<li>
<p>使⽤外部存储介质的话，需要将存储的Key记录下来，恢复的时候再使⽤这些Key将数据取回，实现起来有⼀定的⼯程难度和复杂度。使⽤Kafka的⽇志压缩特性，只需要把数据写进Kafka，等异常出现恢复任务时再读回到内存就可以了</p>
</li>
<li>
<p>Kafka对于磁盘的读写做了⼤量的优化⼯作，⽐如磁盘顺序读写。相对于外部存储介质没有索引查询等⼯作量的负担，可以实现⾼性能。同时，Kafka的⽇志压缩机制可以充分利⽤廉价的磁盘，不⽤依赖昂贵的内存来处理，在性能相似的情况下，实现⾮常⾼的性价⽐（这个观点仅仅针对于异常处理和容灾的场景来说）</p>
</li>
</ul>
</li>
<li>
<ol start="3">
<li>实现细节</li>
</ol>
<p>主题的 cleanup.policy 需要设置为compact。</p>
<p>Kafka的后台线程会定时将Topic遍历两次：</p>
<ol>
<li>
<p>记录每个key的hash值最后⼀次出现的偏移量</p>
</li>
<li>
<p>第⼆次检查每个offset对应的Key是否在后⾯的⽇志中出现过，如果出现了就删除对应的⽇志。</p>
</li>
</ol>
<p>⽇志压缩允许删除，除最后⼀个key之外，删除先前出现的所有该key对应的记录。在⼀段时间后从⽇志中清理，以释放空间。</p>
<p>注意：⽇志压缩与key有关，<strong>确保每个消息的key不为null。</strong></p>
<p>压缩是在Kafka后台通过定时重新打开Segment来完成的，Segment的压缩细节如下图所示：</p>
<img src="/posts/3481392046/14.jpg" class="post-image">
<br>
<p>⽇志压缩可以确保：</p>
<ul>
<li>
<p>任何保持在⽇志头部以内的使⽤者都将看到所写的每条消息，这些消息将具有顺序偏移量。可以使⽤Topic的min.compaction.lag.ms属性来保证消息在被压缩之前必须经过的最短时间。也就是说，它为每个消息在（未压缩）头部停留的时间提供了⼀个下限。可以使⽤Topic的max.compaction.lag.ms属性来保证从收到消息到消息符合压缩条件之间的最⼤延时</p>
</li>
<li>
<p>消息始终保持顺序，压缩永远不会重新排序消息，只是删除⼀些⽽已</p>
</li>
<li>
<p>消息的偏移量永远不会改变，它是⽇志中位置的永久标识符</p>
</li>
<li>
<p>从⽇志开始的任何使⽤者将⾄少看到所有记录的最终状态，按记录的顺序写⼊。另外，如果使⽤者在⽐Topic的log.cleaner.delete.retention.ms短的时间内到达⽇志的头部，则会看到已删除记录的所有delete标记。保留时间默认是24⼩时。</p>
</li>
</ul>
</li>
</ul>
<p>默认情况下，启动⽇志清理器，若需要启动特定Topic的⽇志清理，请添加特定的属性。配置⽇志清理器，这⾥为⼤家总结了以下⼏点：</p>
<ol>
<li>
<p>log.cleanup.policy 设置为 compact ，Broker的配置，影响集群中所有的Topic。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="http://log.cleaner.min.compaction.lag.ms">log.cleaner.min.compaction.lag.ms</a> ，⽤于防⽌对更新超过最⼩消息进⾏压缩，如果没有设置，除最后⼀个Segment之外，所有Segment都有资格进⾏压缩</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="http://log.cleaner.max.compaction.lag.ms">log.cleaner.max.compaction.lag.ms</a> ，⽤于防⽌低⽣产速率的⽇志在⽆限制的时间内不压缩。</p>
</li>
</ol>
<p>Kafka的⽇志压缩原理并不复杂，就是定时把所有的⽇志读取两遍，写⼀遍，⽽CPU的速度超过磁盘完全不是问题，只要⽇志的量对应的读取两遍和写⼊⼀遍的时间在可接受的范围内，那么它的性能就是可以接受的</p>
<h2 id="磁盘存储">磁盘存储</h2>
<h3 id="零拷⻉">零拷⻉</h3>
<p>kafka⾼性能，是多⽅⾯协同的结果，包括宏观架构、分布式partition存储、ISR数据同步、以及“⽆所不⽤其极”的⾼效利⽤磁盘/操作系统特性。</p>
<p>零拷⻉并不是不需要拷⻉，⽽是减少不必要的拷⻉次数。通常是说在IO读写过程中。</p>
<p>nginx的⾼性能也有零拷⻉的身影。</p>
<p>传统IO，⽐如：读取⽂件，socket发送。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer = File.read</span><br><span class="line">Socket.send(buffer)</span><br></pre></td></tr></table></figure>
<p>传统⽅式实现：先读取、再发送，实际经过1~4四次copy。</p>
  <img src="/posts/3481392046/15.jpg" class="post-image">
  <br>
<ol>
<li>
<p>第⼀次：将磁盘⽂件，读取到操作系统内核缓冲区；</p>
</li>
<li>
<p>第⼆次：将内核缓冲区的数据，copy到application应⽤程序的buffer；</p>
</li>
<li>
<p>第三步：将application应⽤程序buffer中的数据，copy到socket⽹络发送缓冲区(属于操作系统内核的缓冲区)；</p>
</li>
<li>
<p>第四次：将socket buffer的数据，copy到⽹络协议栈，由⽹卡进⾏⽹络传输。</p>
</li>
</ol>
<p>实际IO读写，需要进⾏IO中断，需要CPU响应中断(内核态到⽤户态转换)，尽管引⼊DMA(Direct Memory Access，直接存储器访问)来接管CPU的中断请求，但四次copy是存在“不必要的拷⻉”的。</p>
<p>实际上并不需要第⼆个和第三个数据副本。数据可以直接从读缓冲区传输到套接字缓冲区。</p>
<p>kafka的两个过程：</p>
<ol>
<li>
<p>⽹络数据持久化到磁盘 (Producer 到 Broker)</p>
</li>
<li>
<p>磁盘⽂件通过⽹络发送（Broker 到 Consumer）</p>
</li>
</ol>
<p>数据落盘通常都是⾮实时的，Kafka的数据并不是实时的写⼊硬盘，它充分利⽤了现代操作系统分⻚存储来利⽤内存提⾼I/O效率。</p>
<ul>
<li>
<p>磁盘⽂件通过⽹络发送（Broker 到 Consumer）</p>
<p>磁盘数据通过DMA(Direct Memory Access，直接存储器访问)拷⻉到内核态 Buffer 直接通过 DMA 拷⻉到 NIC Buffer(socket buffer)，⽆需 CPU 拷⻉。</p>
<p>除了减少数据拷⻉外，整个读⽂件 ==&gt; ⽹络发送由⼀个 sendfile 调⽤完成，整个过程只有两次上下⽂切换，因此⼤⼤提⾼了性能。</p>
<p>Java NIO对sendfile的⽀持就是FileChannel.transferTo()/transferFrom()。</p>
<p>把磁盘⽂件读取OS内核缓冲区后的fileChannel，直接转给socketChannel发送；底层就是sendfile。消费者从broker读取数据，就是由此实现。</p>
<p>具体来看，Kafka 的数据传输通过 TransportLayer 来完成，其⼦类 PlaintextTransportLayer 通过 Java NIO 的 FileChannel 的 transferTo 和 transferFrom ⽅法实现零拷⻉。</p>
<img src="/posts/3481392046/16.jpg" class="post-image">
<br>
<p><strong>注： transferTo 和 transferFrom 并不保证⼀定能使⽤零拷⻉，需要操作系统⽀持。</strong></p>
<p><strong>Linux 2.4+ 内核通过 sendfile 系统调⽤，提供了零拷⻉。</strong></p>
</li>
</ul>
<h3 id="⻚缓存">⻚缓存</h3>
<p>⻚缓存是操作系统实现的⼀种主要的磁盘缓存，以此⽤来减少对磁盘 I/O 的操作。</p>
<p>具体来说，就是把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问。</p>
<p>Kafka接收来⾃socket buffer的⽹络数据，应⽤进程不需要中间处理、直接进⾏持久化时。可以使⽤mmap内存⽂件映射。</p>
<p>Memory Mapped Files,简称mmap，简单描述其作⽤就是：将磁盘⽂件映射到内存, ⽤户通过修改内存就能修改磁盘⽂件。</p>
<p>它的⼯作原理是直接利⽤操作系统的Page来实现磁盘⽂件到物理内存的直接映射。完成映射之后你对物理内存的操作会被同步到硬盘上（操作系统在适当的时候）。</p>
  <img src="/posts/3481392046/17.jpg" class="post-image">
  <br>
<p>通过mmap，进程像读写硬盘⼀样读写内存（当然是虚拟机内存）。使⽤这种⽅式可以获取很⼤的I/O提升，省去了⽤户空间到内核空间复制的开销。</p>
<p>mmap也有⼀个很明显的缺陷：<strong>不可靠</strong>，写到mmap中的数据并没有被真正的写到硬盘，操作系统会在程序主动调⽤flush的时候才把数据真正的写到硬盘。</p>
<p>Kafka提供了⼀个参数 producer.type 来控制是不是主动flush；</p>
<p>如果Kafka写⼊到mmap之后就⽴即flush然后再返回Producer叫同步(sync)；写⼊mmap之后⽴即返回Producer不调⽤flush叫异步(async)。</p>
<p>Java NIO，提供了⼀个MappedByteBuffer 类可以⽤来实现内存映射。</p>
<p>MappedByteBuffer只能通过调⽤FileChannel的map()取得，再没有其他⽅式。</p>
<p>FileChannel.map()是抽象⽅法，具体实现是在 FileChannelImpl.map()可⾃⾏查看JDK源码，其map0()⽅法就是调⽤了Linux内核的mmap的API</p>
  <img src="/posts/3481392046/18.jpg" class="post-image">
  <br>
<p>使⽤ MappedByteBuffer类要注意的是: <strong>mmap的⽂件映射，在full gc时才会进⾏释放。当close时，需要⼿动清除内存映射⽂件，可以反射调⽤sun.misc.Cleaner⽅法。</strong></p>
<p>当⼀个进程准备读取磁盘上的⽂件内容时：</p>
<ol>
<li>
<p>操作系统会先查看待读取的数据所在的⻚ (page)是否在⻚缓存(pagecache)中，如果存在(命中)则直接返回数据，从⽽避免了对物理磁盘的 I/O 操作。</p>
</li>
<li>
<p>如果没有命中，则操作系统会向磁盘发起读取请求并将读取的数据⻚存⼊⻚缓存，之后再将数据返回给进程。</p>
</li>
</ol>
<p>如果⼀个进程需要将数据写⼊磁盘：</p>
<ol>
<li>
<p>操作系统也会检测数据对应的⻚是否在⻚缓存中，如果不存在，则会先在⻚缓存中添加相应的⻚，最后将数据写⼊对应的⻚。</p>
</li>
<li>
<p>被修改过后的⻚也就变成了脏⻚，操作系统会在合适的时间把脏⻚中的数据写⼊磁盘，以保持数据的⼀致性。</p>
</li>
</ol>
<p>对⼀个进程⽽⾔，它会在进程内部缓存处理所需的数据，然⽽这些数据有可能还缓存在操作系统的⻚缓存中，因此同⼀份数据有可能被缓存了两次。并且，除⾮使⽤Direct I/O的⽅式， 否则⻚缓存很难被禁⽌。</p>
<p>当使⽤⻚缓存的时候，即使Kafka服务重启， ⻚缓存还是会保持有效，然⽽进程内的缓存却需要重建。这样也极⼤地简化了代码逻辑，因为维护⻚缓存和⽂件之间的⼀致性交由操作系统来负责，这样会⽐进程内维护更加安全有效。</p>
<p><strong>Kafka中⼤量使⽤了⻚缓存，这是 Kafka 实现⾼吞吐的重要因素之⼀。</strong></p>
<p><strong>消息先被写⼊⻚缓存，由操作系统负责刷盘任务。</strong></p>
<h3 id="顺序写⼊">顺序写⼊</h3>
<p>操作系统可以针对线性读写做深层次的优化，⽐如预读(read-ahead，提前将⼀个⽐较⼤的磁盘块读⼊内存) 和后写(write-behind，将很多⼩的逻辑写操作合并起来组成⼀个⼤的物理写操作)技术。</p>
  <img src="/posts/3481392046/19.jpg" class="post-image">
  <br>
<p>Kafka 在设计时采⽤了⽂件追加的⽅式来写⼊消息，即只能在⽇志⽂件的尾部追加新的消息，并且也不允许修改已写⼊的消息，这种⽅式属于典型的顺序写盘的操作，所以就算 Kafka 使⽤磁盘作为存储介质，也能承载⾮常⼤的吞吐量。</p>
<p>mmap和sendfile：</p>
<ol>
<li>
<p>Linux内核提供、实现零拷⻉的API；</p>
</li>
<li>
<p>sendfile 是将读到内核空间的数据，转到socket buffer，进⾏⽹络发送。</p>
</li>
<li>
<p>mmap将磁盘⽂件映射到内存，⽀持读和写，对内存的操作会反映在磁盘⽂件上。</p>
</li>
<li>
<p>RocketMQ 在消费消息时，使⽤了 mmap。kafka 使⽤了 sendFile。</p>
</li>
</ol>
<p>Kafka速度快是因为：</p>
<ol>
<li>
<p>partition顺序读写，充分利⽤磁盘特性，这是基础。</p>
</li>
<li>
<p>Producer⽣产的数据持久化到broker，采⽤mmap⽂件映射，实现顺序的快速写⼊。</p>
</li>
<li>
<p>Customer从broker读取数据，采⽤sendfile，将磁盘⽂件读到OS内核缓冲区后，直接转到socket buffer进⾏⽹络发送。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://raoweijiapng.gitee.io">WeiJia Rao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://raoweijiapng.gitee.io/posts/3481392046/">https://raoweijiapng.gitee.io/posts/3481392046/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://raoweijiapng.gitee.io" target="_blank">WeiJia_Rao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/904060711/"><img class="prev-cover" src="/img/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kafka特性之分区</div></div></a></div><div class="next-post pull-right"><a href="/posts/1649525420/"><img class="next-cover" src="/img/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Kafka特性之事务</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/authorPhoto.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">WeiJia Rao</div><div class="author-info__description">饶唯甲的个人博客网站,用于记录平时的学习笔记并展示。努力学习吧,少年!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">409</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">64</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">57</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/raoweijiapng"><i class="fab fa-github"></i><span>My GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:raoweijia@outlook.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/217971296?spm_id_from=333.1007.0.0" target="_blank" title="哔哩哔哩"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="https://weibo.com/p/1005057628848053" target="_blank" title="微博"><i class="fa-brands fa-weibo"></i></a><a class="social-icon" href="https://www.zhihu.com/people/kan-kan-ni-66-95" target="_blank" title="知乎"><i class="fa-brands fa-zhihu"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%BD%87%E5%BF%97%E5%AD%98%E5%82%A8"><span class="toc-number">1.</span> <span class="toc-text">⽇志存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.</span> <span class="toc-text">存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95-2"><span class="toc-number">1.2.1.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">偏移量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">时间戳</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">清理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%BD%87%E5%BF%97%E5%88%A0%E9%99%A4"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">⽇志删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%BD%87%E5%BF%97%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">⽇志压缩</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8"><span class="toc-number">2.</span> <span class="toc-text">磁盘存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E2%BB%89"><span class="toc-number">2.1.</span> <span class="toc-text">零拷⻉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%BB%9A%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">⻚缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%86%99%E2%BC%8A"><span class="toc-number">2.3.</span> <span class="toc-text">顺序写⼊</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3367322272/" title="Linux安装部署高可用k8s集群和Kubesphere">Linux安装部署高可用k8s集群和Kubesphere</a><time datetime="2023-05-25T06:56:18.000Z" title="发表于 2023-05-25 14:56:18">2023-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1799339243/" title="Linux安装部署KubeSphere基于k8s集群">Linux安装部署KubeSphere基于k8s集群</a><time datetime="2023-05-23T11:32:52.000Z" title="发表于 2023-05-23 19:32:52">2023-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2751830321/" title="Linux安装部署高可用k8s集群">Linux安装部署高可用k8s集群</a><time datetime="2023-05-22T01:48:15.000Z" title="发表于 2023-05-22 09:48:15">2023-05-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1833533627/" title="Linux安装部署docker">Linux安装部署docker</a><time datetime="2023-05-22T01:22:08.000Z" title="发表于 2023-05-22 09:22:08">2023-05-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1312854160/" title="Java变量的线程安全分析">Java变量的线程安全分析</a><time datetime="2023-03-10T07:59:19.000Z" title="发表于 2023-03-10 15:59:19">2023-03-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/footer_img.png')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By WeiJia Rao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://raoweijiapng.gitee.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>(function(d, w, c) {
    w.ChatraID = '5QYmoz7m5kBKqo6Hi';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (false) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>